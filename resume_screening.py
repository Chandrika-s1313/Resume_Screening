# -*- coding: utf-8 -*-
"""Resume Screening.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Rfr4_NmeK4QCCnTkscU_o5jqFgnT1GJs
"""

# importing the required libraries

import numpy as np
import pandas as pd
pd.set_option("display.precision", 2)
import seaborn as sns
sns.set_style('whitegrid')
import matplotlib.pyplot as plt
import re
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import TfidfVectorizer
from scipy.sparse import hstack
from sklearn.multiclass import OneVsRestClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn import metrics

# importing and reading the .csv file

df = pd.read_csv('ResumeDataSet.csv')
print("The number of rows are", df.shape[0],"and the number of columns are", df.shape[1])
df.head()

# Checking the information of the dataframe(i.e the dataset)

df.info()

# Checking all the different unique values
df.nunique()

# Plotting the distribution of Categories as a Count Plot

plt.figure(figsize = (15,15))
sns.countplot(y = "Category", data = df)
df["Category"].value_counts()

import matplotlib.pyplot as plt

plt.figure(figsize=(18, 18))

# Assuming 'Category' is the correct column name
Category_counts = df['Category'].value_counts()
labels = Category_counts.index
sizes = Category_counts.values

plt.title("Categorywise Distribution", fontsize=20)
plt.pie(sizes, labels=labels, autopct='%1.2f%%', shadow=True)
plt.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.

plt.show()

# Function to clean the data

def clean(data):
    data = re.sub('httpS+s*', ' ', data)                                                    # Removing the links
    data = re.sub('RT|cc', ' ', data)                                                       # Removing the RT and cc
    data = re.sub('#S+', ' ', data)                                                         # Removing the hashtags
    data = re.sub('@S+', ' ', data)                                                         # Removing the mentions
    data = data.lower()                                                                     # Changing the test to lowercase
    data = ''.join([i if 32 < ord(i) < 128 else ' ' for i in data])                         # Removing all the special characters
    data = re.sub('s+', 's', data)                                                          # Removing extra whitespaces
    data = re.sub('[%s]' % re.escape("""!"#$%&'()*+,-./:;<=>?@[]^_`{|}~"""), ' ', data)     # Removing punctuations
    return data
cleaned_df = df['Category'].to_frame()
cleaned_df['Resume'] = df['Resume'].apply(lambda x: clean(x))                               # Applying the clean function
cleaned_df

# Encoding the Category column using LabelEncoder

encoder = LabelEncoder()
cleaned_df['Category'] = encoder.fit_transform(cleaned_df['Category'])
cleaned_df

# Encoded Classes

encoder.classes_

# Creating a Word Vectorizer and transforming it

Resume = cleaned_df['Resume'].values
Category = cleaned_df['Category'].values
word_vectorizer = TfidfVectorizer(sublinear_tf = True, stop_words = 'english', max_features = 1000)
word_vectorizer.fit(Resume)
WordFeatures = word_vectorizer.transform(Resume)

# Splitting the data into train, test, printing the shape of each and running KNeighborsClassifier with OneVsRest method.

X_train, X_test, y_train, y_test = train_test_split(WordFeatures, Category, random_state=2, test_size = 0.2)
print(f'The shape of the training data {X_train.shape}')
print(f'The shape of the test data {X_test.shape}')
clf = OneVsRestClassifier(KNeighborsClassifier())
clf.fit(X_train, y_train)

# Predicting the values using the model built with train data and checking the appropriate metrics

prediction = clf.predict(X_test)
print(f'Accuracy of KNeighbors Classifier on test set: {clf.score(X_test, y_test):.2f}\n')
print(f'The classification report \n {metrics.classification_report(y_test, prediction)}\n\n')

print(prediction)

print(encoder.inverse_transform(prediction))

# Function to predict the category of a resume
def predict_resume_category(resume_text):
    cleaned_text = clean(resume_text)
    vectorized_text = word_vectorizer.transform([cleaned_text])
    category_encoded = clf.predict(vectorized_text)
    category = encoder.inverse_transform(category_encoded)
    return category[0]

# Example usage
resume_text = "Looking for a Python Developer."
predicted_category = predict_resume_category(resume_text)
print("Predicted category:", predicted_category)

# Determine if the candidate is shortlisted based on the predicted category
shortlisted_categories = ['Python Developer','Software Developer']  # Define the categories that are considered for shortlisting

if predicted_category in shortlisted_categories:
    print("Candidate is shortlisted!")
else:
    print("Candidate is not shortlisted.")



def predict_resume_category(resume_text):
    cleaned_text = clean(resume_text)
    vectorized_text = word_vectorizer.transform([cleaned_text])
    category_encoded = clf.predict(vectorized_text)
    category = encoder.inverse_transform(category_encoded)
    return category[0]

# Example usage
resume_text = "Looking for a law graduate who have deep knowledge in laws."
predicted_category = predict_resume_category(resume_text)
print("Predicted category:", predicted_category)

# Determine if the candidate is shortlisted based on the predicted category
shortlisted_categories = ['Python Developer','Software Developer']  # Define the categories that are considered for shortlisting

if predicted_category in shortlisted_categories:
    print("Candidate is shortlisted!")
else:
    print("Candidate is not shortlisted.")

def predict_resume_category(resume_text):
    cleaned_text = clean(resume_text)
    vectorized_text = word_vectorizer.transform([cleaned_text])
    category_encoded = clf.predict(vectorized_text)
    category = encoder.inverse_transform(category_encoded)
    return category[0]

# Example usage
resume_text = "Require a person who can guide others about health "
predicted_category = predict_resume_category(resume_text)
print("Predicted category:", predicted_category)

# Determine if the candidate is shortlisted based on the predicted category
shortlisted_categories = ['Python Developer','Software Developer']  # Define the categories that are considered for shortlisting

if predicted_category in shortlisted_categories:
    print("Candidate is shortlisted!")
else:
    print("Candidate is not shortlisted.")